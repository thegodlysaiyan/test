"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _terraArrange = _interopRequireDefault(require("terra-arrange"));

var _IconCheckmark = _interopRequireDefault(require("terra-icon/lib/icon/IconCheckmark"));

var _IconChevronRight = _interopRequireDefault(require("terra-icon/lib/icon/IconChevronRight"));

var _IconConsultInstructionsForUse = _interopRequireDefault(require("terra-icon/lib/icon/IconConsultInstructionsForUse"));

var _bind = _interopRequireDefault(require("classnames/bind"));

var KeyCode = _interopRequireWildcard(require("keycode-js"));

var _MenuItemModule = _interopRequireDefault(require("./MenuItem.module.scss"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var cx = _bind.default.bind(_MenuItemModule.default);

var contextTypes = {
  isGroupItem: _propTypes.default.bool,
  isSelectableMenu: _propTypes.default.bool
};
var propTypes = {
  /**
   * Sets the item's text.
   */
  text: _propTypes.default.string,

  /**
   * Indicates if item should be disabled
   */
  isDisabled: _propTypes.default.bool,

  /**
   * Indicates if the item is selected. A selected item is indicated with a checkmark.
   */
  isSelected: _propTypes.default.bool,

  /**
   * Indicates if the item should be selectable.
   */
  isSelectable: _propTypes.default.bool,

  /**
   * Displays the  eIFU (electronic instructions for use) icon for menu item if set to true. (This icon is used to indicate Help content that is the equivalent of an instruction manual)
   */
  isInstructionsForUse: _propTypes.default.bool,

  /**
   * List of Menu.Items to display in a submenu when this item is selected.
   */
  subMenuItems: _propTypes.default.arrayOf(_propTypes.default.element),

  /**
   * Callback function for when item is clicked
   */
  onClick: _propTypes.default.func,

  /**
   * Callback function for when selection state changes on a selectable item.
   */
  onChange: _propTypes.default.func,

  /**
   * Indicates if the item has focus. This is used internally to control focus and does not set initial focus.
   */
  isActive: _propTypes.default.bool
};
var defaultProps = {
  text: '',
  isSelected: false,
  isInstructionsForUse: false,
  isActive: false,
  isSelectable: undefined,
  isDisabled: false,
  subMenuItems: []
};

var MenuItem = /*#__PURE__*/function (_React$Component) {
  (0, _inherits2.default)(MenuItem, _React$Component);

  function MenuItem(props, context) {
    var _this;

    (0, _classCallCheck2.default)(this, MenuItem);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MenuItem).call(this, props, context));
    _this.wrapOnClick = _this.wrapOnClick.bind((0, _assertThisInitialized2.default)(_this));
    _this.wrapOnKeyDown = _this.wrapOnKeyDown.bind((0, _assertThisInitialized2.default)(_this));
    _this.wrapOnKeyUp = _this.wrapOnKeyUp.bind((0, _assertThisInitialized2.default)(_this));
    _this.handleSelection = _this.handleSelection.bind((0, _assertThisInitialized2.default)(_this));
    _this.setItemNode = _this.setItemNode.bind((0, _assertThisInitialized2.default)(_this));
    _this.state = {
      isSelected: props.isSelected && props.isSelectable && !context.isGroupItem,
      isActive: false
    };
    return _this;
  }

  (0, _createClass2.default)(MenuItem, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.props.isActive && this.itemNode) {
        this.itemNode.focus();
      }
    }
  }, {
    key: "setItemNode",
    value: function setItemNode(node) {
      if (node) {
        this.itemNode = node;
      }
    }
  }, {
    key: "handleSelection",
    value: function handleSelection(event) {
      event.preventDefault();

      if (this.props.isSelectable && !this.context.isGroupItem && !this.props.isDisabled) {
        this.setState(function (prevState) {
          return {
            isSelected: !prevState.isSelected
          };
        });

        if (this.props.onChange) {
          this.props.onChange(event, !this.state.isSelected);
        }
      }
    }
  }, {
    key: "wrapOnClick",
    value: function wrapOnClick(event) {
      this.handleSelection(event);

      if (this.props.onClick) {
        this.props.onClick(event);
      }
    }
  }, {
    key: "wrapOnKeyDown",
    value: function wrapOnKeyDown(onKeyDown) {
      var _this2 = this;

      return function (event) {
        if (event.nativeEvent.keyCode === KeyCode.KEY_RETURN || event.nativeEvent.keyCode === KeyCode.KEY_SPACE) {
          _this2.handleSelection(event); // Only add active style if the menu doesn't have a sub menu to avoid active style being stuck enabled


          if (!(_this2.props.subMenuItems && _this2.props.subMenuItems.length > 0)) {
            _this2.setState({
              isActive: true
            });
          }

          if (_this2.props.onClick) {
            _this2.props.onClick(event);
          } // Remove active state when tab key is released while while holding the space key to avoid active style being stuck enabled

        } else if (event.nativeEvent.keyCode === KeyCode.KEY_TAB) {
          _this2.setState({
            isActive: false
          });
        }

        if (onKeyDown) {
          onKeyDown(event);
        }
      };
    }
  }, {
    key: "wrapOnKeyUp",
    value: function wrapOnKeyUp(onKeyUp) {
      var _this3 = this;

      return function (event) {
        if (event.nativeEvent.keyCode === KeyCode.KEY_RETURN || event.nativeEvent.keyCode === KeyCode.KEY_SPACE) {
          _this3.setState({
            isActive: false
          });
        }

        if (onKeyUp) {
          onKeyUp(event);
        }
      };
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          text = _this$props.text,
          isDisabled = _this$props.isDisabled,
          isSelected = _this$props.isSelected,
          isInstructionsForUse = _this$props.isInstructionsForUse,
          isSelectable = _this$props.isSelectable,
          subMenuItems = _this$props.subMenuItems,
          isActive = _this$props.isActive,
          customProps = (0, _objectWithoutProperties2.default)(_this$props, ["text", "isDisabled", "isSelected", "isInstructionsForUse", "isSelectable", "subMenuItems", "isActive"]);
      var _this$context = this.context,
          isGroupItem = _this$context.isGroupItem,
          isSelectableMenu = _this$context.isSelectableMenu;

      var attributes = _objectSpread({}, customProps);

      attributes.tabIndex = isDisabled ? '-1' : '0';
      attributes['aria-disabled'] = isDisabled; // This is passed down by the single select list in group item and not needed

      delete attributes.hasChevron;

      if (isDisabled) {
        delete attributes.onClick;
        delete attributes.onKeyDown;
      } else {
        attributes.onClick = this.wrapOnClick;
        attributes.onKeyDown = this.wrapOnKeyDown(attributes.onKeyDown);
        attributes.onKeyUp = this.wrapOnKeyUp(attributes.Up);
      }

      var markAsSelected = this.state.isSelected || isGroupItem && isSelected;
      var itemClassNames = cx(['item', {
        selected: markAsSelected
      }, {
        'is-disabled': isDisabled
      }, // eslint-disable-next-line quote-props
      {
        'active': this.state.isActive
      }, attributes.className]);

      var textContainer = _react.default.createElement("div", {
        className: cx('text')
      }, text);

      var hasChevron = subMenuItems.length > 0;
      var content = textContainer;

      if (hasChevron || isSelectableMenu || isInstructionsForUse) {
        var fitStartIcon = null;

        if (isInstructionsForUse) {
          fitStartIcon = _react.default.createElement(_IconConsultInstructionsForUse.default, {
            className: cx('start-icon')
          });
        } else if (isSelectableMenu) {
          fitStartIcon = _react.default.createElement(_IconCheckmark.default, {
            className: cx(['checkmark', 'start-icon'])
          });
        }

        content = _react.default.createElement(_terraArrange.default, {
          fitStart: fitStartIcon,
          fill: textContainer,
          fitEnd: hasChevron ? _react.default.createElement(_IconChevronRight.default, {
            className: cx('chevron')
          }) : null,
          align: "center"
        });
      }

      var role = 'menuitem';

      if (isGroupItem) {
        role = 'menuitemradio';
      } else if (isSelectable) {
        role = 'menuitemcheckbox';
      }

      return _react.default.createElement("li", (0, _extends2.default)({}, attributes, {
        className: itemClassNames,
        ref: this.setItemNode,
        role: role,
        "aria-checked": markAsSelected
      }), content);
    }
  }]);
  return MenuItem;
}(_react.default.Component);

MenuItem.propTypes = propTypes;
MenuItem.defaultProps = defaultProps;
MenuItem.contextTypes = contextTypes;
var _default = MenuItem;
exports.default = _default;